
// if ( WEBGL.isWebGLAvailable() === false ) {

//   document.body.appendChild( WEBGL.getWebGLErrorMessage() )

// }

const bubbles = document.querySelector('.wreckit')

var container

var camera, scene, renderer

var spheres = []

// var mouseX = 0, mouseY = 0

var windowHalfX = window.innerWidth / 2
var windowHalfY = window.innerHeight / 2

// document.addEventListener( 'mousemove', onDocumentMouseMove, false )

init()
animate()

function init() {
  const container = document.createElement( 'div' )

  bubbles.addEventListener('click', function() {
    container.className = "bubbles"
      document.body.appendChild( container )
      setTimeout(function(){
        document.body.removeChild( container )
      },5000)
  })


  camera = new THREE.PerspectiveCamera( 60, window.innerWidth / window.innerHeight, 1, 100000 )
  camera.position.z = 3200



  // var path = "<%= asset_path('screen.png') %>"

  // var format = '.png'
  // var urls = [
  // path + 'screen' + format, path + 'screen' + format,
  // path + 'screen' + format, path + 'screen' + format,
  // path + 'screen' + format, path + 'screen' + format
  // ]

  var urls = ["<%= asset_path('screen.png') %>", "<%= asset_path('screen.png') %>", "<%= asset_path('screen.png') %>","<%= asset_path('screen.png') %>","<%= asset_path('screen.png') %>","<%= asset_path('screen.png') %>"]
  var textureCube = new THREE.CubeTextureLoader().load( urls )
  textureCube.format = THREE.RGBFormat
  textureCube.minFilter = THREE.LinearFilter

  scene = new THREE.Scene()
  // scene.background = textureCube



  var geometry = new THREE.SphereBufferGeometry( 100, 32, 16 )

  var shader = THREE.FresnelShader
  var uniforms = THREE.UniformsUtils.clone( shader.uniforms )

  uniforms[ "tCube" ].value = textureCube

  var material = new THREE.ShaderMaterial( {
    uniforms: uniforms,
    vertexShader: shader.vertexShader,
    fragmentShader: shader.fragmentShader
  } )

  for ( var i = 0; i < 500; i ++ ) {

    var mesh = new THREE.Mesh( geometry, material )

    mesh.position.x = Math.random() * 10000 - 5000
    mesh.position.y = Math.random() * 10000 - 5000
    mesh.position.z = Math.random() * 10000 - 5000

    mesh.scale.x = mesh.scale.y = mesh.scale.z = Math.random() * 3 + 1

    scene.add( mesh )

    spheres.push( mesh )

  }



  renderer = new THREE.WebGLRenderer({ alpha: true })
  renderer.setClearColor( 0xffffff, 0 )
  renderer.setPixelRatio( window.devicePixelRatio )
  renderer.setSize( window.innerWidth, window.innerHeight )
  container.appendChild( renderer.domElement )



  window.addEventListener( 'resize', onWindowResize, false )

}

function onWindowResize() {

  windowHalfX = window.innerWidth / 2
  windowHalfY = window.innerHeight / 2

  camera.aspect = window.innerWidth / window.innerHeight
  camera.updateProjectionMatrix()

  renderer.setSize( window.innerWidth, window.innerHeight )

}

// function onDocumentMouseMove( event ) {

//   mouseX = ( event.clientX - windowHalfX ) * 10
//   mouseY = ( event.clientY - windowHalfY ) * 10

// }



function animate() {

  requestAnimationFrame( animate )

  render()

}

function render() {

  var timer = 0.0001 * Date.now()

  // camera.position.x += ( mouseX - camera.position.x ) * .05
  // camera.position.y += ( - mouseY - camera.position.y ) * .05

  camera.lookAt( scene.position )

  for ( var i = 0, il = spheres.length; i < il; i ++ ) {

    var sphere = spheres[ i ]

    sphere.position.x = 5000 * Math.cos( timer + i )
    sphere.position.y = 5000 * Math.sin( timer + i * 1.1 )

  }

  renderer.render( scene, camera )

}

